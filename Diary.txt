Creating a Django website
*************************

Setting up the project
**********************
-create the github repo:
	echo "# Django_Website" >> README.md
	git init
	git add README.md
	git commit -m "first commit"
	git branch -M main
	git remote add origin https://github.com/Robzabel/Django_Website.git
	git push -u origin main
	
- Installed django
	pipenv install django
	
-create a new Django project:
	django-admin start project mysite
	
-The manage.py file is the brains ofthe project where we will orchestrate eveything that happens within the project.
- We can test that the development server is working by changing into the project directory and typing:
	python3 manage.py runserver (optionally specify the port number here)
	
-The outer folder is the root directory of the site and the inner folder is the project handling folder with the same name	
- So far we have basically created an environment to host our web applications. We next need to start creating the applications.


Creating applications and Directing Requests Using Urls
*******************************************************
- from the root directory, use the command:
	python manage.py startapp main

-In the main dir, you have the views file which is where you define the views(functions for each website page) for the application.
- start by importing HTTP response from the django http library:
	from django.http import HttpResponse

- Next define the view(s) that you want. we are keeping it simple at the moment and just returning hello world.
- When writing the view function we need to accept an argument which is normally called request or response. the function must always return a response, wheather that is using the httpresponse module or simply returning the Request/response peramaters that were supplied. Here we have an example of each instance:


	def index(response, id):
   	   return HttpResponse("<h1> hello world</h1>") # this uses httpresponse so doesnt need to return the 	response argument passesd to it


	def home(response):
    	   return render( response,  "main/home.html") #this uses the render module so needs to return the response argument passed to it

- once we have the views set up, we need to create a file in the app directory called urls.py. This URL's file will direct the http traffic around the application that it is stored in. Kind of like how in flask you have route decorators above each view to signify how to get to it, in Django the routes get separated into a different file.
- firstly we need to import a few things:
	from django.urls import path  #this is not the same as the standard path library
	from . import views #this imports views from the same folder represented by the "."
- we then need to create a list that contains the path to the function name which we defined within the views file:

urlpatterns = [
    path("", views.index, name="index"),
]

-So what we have stated here ^ is that there is a path to a view that we want to be named index. When a request is sent to "" direct it to the views file and the index function. the "" means that there is no matching criteria so if any web traffic comes this way and it is not going to any other specific path, send it here. 

-now we need to go back to the project folder called "mysite" and open the urls.py file in there. because this urlsfile is from the project folder, it is addressed first when a request comes into the website, the file is then checked and the traffic is forwarded to the urls folder of the correct application which is specified in the urlpatterns list on this page.
- This is because a project can have more than one application but the applications are programme agnostic which means they dont know about anything other than themselves so if traffic is not meant for them they would just drop it. The project urls file orchestrates where traffic should be sent as it has an overview of all paths possible from the web address.
- we need to add a path to the url folder of our main application but first we need to add the import for include from the django.urls module.
- we then use the include module when specifying a path in the urlpatterns list:
	
	
urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include("main.urls")),
]

-This means that if nothing is typed as a url, hence the empty string, then the request will be forwarded to the main app and the urls file in which it will then be directed to the correcty place on the app.
-whenever django encounters include(), it chops off whatever part of the URL matched up to that point and sends the remaining string to the included URLconf for further processing.
-When to use include()? You should always use include() when you include other URL patterns. admin.site.urls is the only exception to this.
	


Setting up Databases
********************
-its a good idea to set up the database next before the web pages as it is the data from the datase that you want to access so you need to have something there to display first.
-To include an application in the project we need to make it known in the main settings.py file. to do this, open up the file and scroll down to where it says installed apps, at the bottom of the list add the line:
	
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'main.apps.MainConfig',
]
- this tells Django that in the main folder there is a file called apps and in that file you will find a class called MainConfig.This class is automatically created when setting up the app and is a combination of the app filename and Config so if i had called my app Rob for some reasn, the class would be called RobConfig and the line to add to the INSTALLED_APPS list would be:

	'rob.apps.RobConfig',
	
- make sure to use single quotes and put a comma at the end for some reason.
-Whenever we make a change to the installed apps list, we need to run the command:
	
	python manage.py migrate
	
-The migrate command looks at the INSTALLED_APPS setting and creates any necessary database tables according to the database settings in your mysite/settings.py file and the database migrations shipped with the app. You’ll see a message for each migration it applies. If you’re interested, run the command-line client for your database and type \dt (PostgreSQL), SHOW TABLES; (MariaDB, MySQL), .schema (SQLite), or SELECT TABLE_NAME FROM USER_TABLES; (Oracle) to display the tables Django created

-next we need to define the models of the database. this is similar to the way we do it in Flask but slightly different.
- Each class will be a subclass (inherit from) of django.db.models.model each filed is represented by an instance of the Model.Field() calss.
- when specifying the models, Django does a lot of the relational database aspects for you:
	*Table names are automatically generated by combining the name od the app andthe the lowercase name of the model(you can actually override this behaviour though)
	*Primary key ID fields are added automatically, but you can override this too
	*by convention, django adds _id to the end of the foreign key name, you can override this too
	*The foreign key relationship is made explicit by a foreign key constraint, the DEFERRABLE keyword is used to tell PostgreSQL not to enforce the foreignkey until the end of the transaction.
- When it comes to the databases, you can run "python manage.py check" which will check for any problems in the project without making migrations or touching the database.
- You need to run migrate again to create model tables in the database.


Creating Models
***************
- All models are clases that inherit from the models.Model class, just as Flask models inherit from the db.modles class.
-when defining the colums of the model, you need to use the properties of the models superclass, each property is called a Field of some type such as the CharFileld which referrs to string datatype columns.
- As with Flask, when you define a CharField (string valuse column) you need to give a character limit to the model below is an example:

	class ToDoList(models.Model):
	    name = models.CharField(max_length=200)
	    
- It is a good idea to define a __repr__ method as well so that the user can call it and quickly find a description of what the table is for. However, when using the API to work with the database, it doesnt understanf the repr method so we need to ass a string method of the same thing so that the API can work with it:
		
		
- when declaring foreign Key columns, you simply make a column then define it as a ForeignKey type and provide the the table that you want to link to not the colum which feels wierd but django creates the ID fields on each table automatically and behind the scenes, it will add the _id tag to the table then it knows to use the ID column as the primary key.
- When you make the primary key field, you also need to specify what to do when an item from the table that it is linked to, is deleted as in if you had a users table and a blog table, you would set a foreign key on the blog table pointing back to the users table as a user creates a blog. If a user is deleted, you dont want their blogs to be kept as it is redundant data. This is why you need to specify that when you delete an Item in the table that holds the foreign key, you want it to CASCADE down to the other table and remove any data that it is associated with there.

	 class Item(models.Model):
   	 todolist = models.ForeignKey(ToDoList, on_delete=models.CASCADE)
	    
-now that we have made the tables, we need to run a command that does the same thing as staging in Git when you use the git add filename. We will stage the changes to the django app first then commit them with the migrate conmmand

	python manage.py makemigrations (app name)
- you should get the following output:
	
	Migrations for 'main':
  	main/migrations/0001_initial.py
	    - Create model ToDoList
	    - Create model Item
-NOw we need to comit the changes:

	python manage.py migrate    
	   
- we should get a confirmation message in the terminal and if you look in the migerations afile under the dir of the application, you will see the changes in a file. every time you make changes they are recorded here so you can roll back if you fuck somethiong up, which is nice.


Adding Data to Models
*********************
-Now that we have the database and the models created, we need to start adding data to them. 
-We can do this using the API that is created for us by django. Get into an interactive shell by typing in a terminal:
	
	python manage.py shell
	
-We’re using this instead of simply typing “python”, because manage.py sets the DJANGO_SETTINGS_MODULE environment variable, which gives Django the Python import path to your mysite/settings.py file.
-first we need to import our models as we are in the mysite directory so it wont know what we are talking about:
	
	from main.models import Item, ToDoList	    

-from here we create an object of the todolist and give it a name peramater. we then add the object to the database by using the .save() method on it:

	
	>>> to_do = ToDoList(name="Robs Todo")
	>>> to_do.save()

-We can get all the elements from a table by calling the objects.all() method on the name of the table, so in this case i would use:
	
	>>> ToDoList.objects.all()
	<QuerySet [<Todo Name: Robs Todo>]>

-We can also retrieve different objects through filteing the request:

	>>> ToDoList.objects.get(id=1)
	<Todo Name: Robs Todo>

- when we created the foreign key relationshiop from the Items table to the todolist table, behind the scenes, django creates a set which is used to hold "the other side" of a foreign key's relationship. what this means is, because Items has a foreign key linking it to the todolist table, there will be a method called items_set which we can use on the todolist object and pass the field information as paramaters. This is then entered into the Items table:
	
	to_do.item_set.all() #this will retrieve all the information from the Items table
	to_do.item_set.create(text="Go shopping", complete=False)

- We can get specific information from the tables by using filtering statements:
	t = ToDoList.objects
	t.filter() #need to apass filter arguments to the function
-Filter arguments normally start with a double underscore. An example would be __startswith = ""
- to delete items from a table, you need to make an object of the item then call the delete method on it:
	del_object = t.get(id=1)
	del_object.delete()


Show to do lists on the website
********************************
-in the application's URLs.py file we can change the path to look for dynamic input. What this basically means is going back to where you use <int:id> int the path so that a user can pass a value to the web address and we can return the corresponding to do list.
-where we had previously written "" to catch any traffic going to the site, add the <int:id> tag.
	    
	urlpatterns = [
	path("<int:id>", views.index, name="index"),
	]
	    
- Now we can go to our apps Views.py file and change the index function to accept a parameter for ID so we can use it to query the DB.

	def index(response, id):
	    get_list = ToDoList.objects.get(id=id)
	    return HttpResponse(f"<h1>The name of the to do list is {get_list.name} </h1>")

- Now when we go to the utl of http://127.0.0.1/8000/1 we get teh message followed by the database item.


Admin Dashboard
****************
- THe Django admin dashboard can be accesses by going to the page in a browser with the /admin extension.
-This takes us to a log in page. We need to create the admin user and define the credentials before we log in. To do this, go to the terminal of the project and type:

	python manage.py createsuperuser

- This takes you to a guided menu where you create the admin credentials
email
Password123!    
- From the admin panel you can control the data in the databases. Our database that we created doesnt show up here yet because we need to allow the newly created admin access to it.
- go to the admin.py file in the main application folder. first we meed to import our database models into the folder, since the Items table is linked to the todolist table, we only need to give access to the TDlist table:

	from .models import ToDoList

- next we need to add the line below to register the table with the admins access rights:
	
	admin.site.register(ToDoList)


Creating Templates for the Website
***********************************
-To create more views and make the app start looking like a website, first we need to set a url to get to the view we are going to create. in the URLS file of the application, add a new pattern:

	path("", views.home, name="home")

- now we need to go to the views file and add a function called home. for now we will just write it as a pass function because we want to start designing the templates first.
- int the main file make a folder called templates, then in that file make another file called main. this is becasue Django will look in the templates file for a folderthe same name as the application so that it can pull the correct templates.
-start off by making a base template by opening a new file nad using the ! to make a standard HTML base file. we then want to create a home file which will contain the formatting for the home page that will run over the base template.
- in the home file, we will be using Jinja2 just like in flask so we need to use the syntax to extend the base page:
	
	{% extends 'main/base.html'%}	    

- next, on the base template we need to set up our content block so go to the body tags on base,html and create a new div that contains the jinja syntax:

	 <body>
    		<div id="content", name="content">
        		{% block content %}
        		{% end block %}
   		 </div>
	 </body>
- then in the home template, you need to put the home specific content within the content block syntax as well:

{% block content %}
<h1>Hello Rob, this the home page</h1>
{% endblock %}    

- we also can add the block title to the base template which can let us change the title of each page.
- now that we are creating templates for the pages of the website we need to use the render method of retunring the page in the views file. we can also pass variables to the page the same way we do in flask, however we need to pass them in a dictionary format for some reason:
	
def index(response, id):
    ls = ToDoList.objects.get(id=id)
    return render(response, 'main/list.html', {"ls": ls})

- now that we are returning a to do list to our page, we can write a for loop in jinja to loop through the items associated with the list:

{% block content %}
    <h1>{{ ls.name }}</h1>
    <ul>
        {% for item in ls.item_set.all %}
            <li>{{ item.text }}</li>
        {% endfor %}
    </ul>
{% endblock %}


- just need to add some items to the list:

	python manage.py shell
	ls1 = ToDoList.objects.get(id=1)
	ls1.item_set.create(text="first Item", complete=False)
	ls1.item_set.create(text="Second Item", complete=False)
	ls1.item_set.create(text="Third Item", complete=False)
	quit()


Simple Forms
*************
- Start by making a new URL mapping in the URLs.py file called create. This will be the view that takes users to a form that will input data into the database. Add the following line to the urlpatterns list:
	
	path("create/", views.create, name="create")
- Next go to the views file and create a new view that renders the create,html file.
-Next, make the create.html file by inheriting from the base.html file and addin content &title blocks.
-Django will actually take all the hastle out of creating a form. all we need to do is create the HTML form using the <form> tags and add a submit button. After that we add the {{ form }} variable and django does the rest.

	{% block content %}
    		<form method="post" action=#>
        		{{ form }}
        		<button type="submit", name="save" >Create New</button>
    		</form>
	{% endblock %}

-We need to create a new file to hold the forms in the application main directory. forms.py

- In the forms file, we import the forms module from django
	
	from django impoprt forms

-Create a class called whatever you want the name of your form to be and inherit from the forms.Form class. (make sure the Form has a capital F.
-We need to make the fields of the form the same as the rows of the models so that they can obviously hold the exact same type of data. You declare the fields of the form in almost the exact same way you declare the fields of the model using inherited class method with capital letters:
	
	class Create_new_list(forms.Form):
		name = forms.CharField(max_length=300, label="name") #label is the form placeholder
		check = forms.BooleanField()
- You can now reload the webserver and when you visit the site, the forms page will be displaying a nice little formatted form.
- You can add extensions to the {{ form }} tag to change the basic default layout of the form. For this instance i am using the {{ form.as_p }}format which shows the form item fields under one another.
- you can see that Django automatically adds JavaScript to flash an alert if you try clicking submit without fillin in the form, this is a nice touch but at the same time we need to be aware that if we dont specify things as optional, the JS wont let the user proceed without completing the all parts of the form. For instance the complete radio button, if it it clicked then the todo is marked as complete but without specifying that it is optional, the JS wont let the user create the todo until it is clicked.
- To make form elements optional, we can use the required = False line inside the parenthesis:
	
	check = forms.BooleanField(required=False)

- now we can submit the form without having to click the complete radio button. However if we do submit the form at the moment, we get a CRSF error. This is a security error and is brought up becasue whenever we create a form in django, we need to specify a crsf token to go with it. To do this we need to add the jinja tag inside the form tag on the html document as follows:

	{% block content %}
	<h1> Create New List</h1>
	    <form method="post" action=#>
		{% csrf_token %}
		{{ form.as_p }}
		<button type="submit", name="save" >Create New</button>
	    </form>
	{% endblock %}

- The difference between post and aget is that get is sent in plain test through the url whereas post is hidden fronm the URL bar and is sent encrypted. with Django, the response argument that is passed to all view functions is able to tell whether a post or get request was sent.
- TO access the data that is sent in the post request we first need an if statement to check if it was a GET/POST request that the view recieved and if it was POST, we need to validate the data then add it to the database:

	def create(response):
	    if response.method == "POST":
		form = Create_new_list(response.POST) #take the data from the POST request and add it to the form

		if form.is_valid(): #validate the form data received in the POST request
		    n = form.cleaned_data["name"]#clean the data and grab the name value
		    t = ToDoList(name=n) #pass the name to the list argument
		    t.save() #save the new to do list to the database
		    
	    else:
		form = Create_new_list()
		return render( response, "main/create.html", {"form":form})



*response.POST is a dictionary-like object that lets you access submitted data by key name. In this case, response.POST['choice'] returns the ID of the selected choice, as a string. response.POST values are always strings.
*Note that Django also provides response.GET for accessing GET data in the same way – but we’re explicitly using response.POST in our code, to ensure that data is only altered via a POST call.
*Form.is_valid() runs a validation check by matching the data recieved with the constraints of the form.
*Form.cleaned_data¶
Each field in a Form class is responsible not only for validating data, but also for “cleaning” it – normalizing it to a consistent format. This is a nice feature, because it allows data for a particular field to be input in a variety of ways, always resulting in consistent output.
For example, DateField normalizes input into a Python datetime.date object. Regardless of whether you pass it a string in the format '1994-07-15', a datetime.date object, or a number of other formats, DateField will always normalize it to a datetime.date object as long as it’s valid.
Once you’ve created a Form instance with a set of data and validated it, you can access the clean data via its cleaned_data attribute:

- Now that we are able to add new to do lists, to make it do that the user is aware the list was created, We need to redirect them to a page that displays it. To do this, first we need to import the HTTPResponseRedirect module from django.http:

	from django.http import HttpResponseRedirect
	
- next we add a return statement to the view function inside the if block that catches POST requests:
	
	return HttpResponseRedirect("/%i" %t.id)
	
- this redirects the user to the index page/ the id of the list which is pretty clever.



Custom Forms
************
- Now that we have seen what Django can do by default, we will make some customisations to our list template using forms to retrieve data.
-Our list page prints the items of the todo list but currently, we have no means of adding new items to the lists or updating them. here is where the custom form comes into play. I will make the current content block into a POST form and add buttons to add and update the lists, we can then capture the user input in the same way we did with the form to create the lists.
- we have made two buttons (save and newItem) so we need a way to determine which one was clicked to send the from.
- The code from this section has nothing new just stuff very specific to this project so check the code for examples on what we did.


Adding a Side Bar
*****************
-The backend is pretty much finished now so it is going to be focusing more of front end from here.
-We need to work on the base template for the html to carry over into the other templates.
-ON the base template add a div with the class name of Sidenav, then add a few links (a href tags).
- we will start by using CSS on the side nav. remember that a full stop represents a class when calling html elements with CSS so to referr to the nav bar which we have given the class of sidenav, we would write .sidenav if you were calling based on ID then you use the hashtag.
-next i just added the CSS that was written on the site.


Adding Bootstrap
****************
-bootstrap was atraight forward, just go to the website and copy the shit to your page then style it the way you want.


Urser Registration and Sign Up Page
***********************************
- the first thing we will need to do is create a new application in the Django project that will handle the user athentication login/logout actions.
- We can actually use this user authentication apllication in other Django projects simply by copy and pasting it which is very handy.
-to create the new application, go the command line and type:
	
	python manage.py startapp register

-after creating the app we need to add it to the list of installed apps in the settings.py file of the project folder:
	'register.apps.RegisterConfig'

-Now that we have the new app, go to the views file and add a simple view for now just so that we can sort out the url mappings from the project file:
	
	def register(response):
		return render


-we need to add our new view to our URLs patern list so that it can be accessed. In the "mysite" folder which is the folder that handles everything to do with the project, go to the urls file. make sure this is not just the "main" application's urls file.
-In the file it is a bit different than when we added the url pattern for the main application. because we dont want to direct the traffic to the urls file of the register application, since we only have 1 view, we need to import the view in the file and forward traffic directly to it:

	from register import views as regView

- the resason we have imported it as regView is because if this was a big project with lots of different apps, you would be importing lots of views files and it wouldnt work if you imported them all as "views" so we changethe name to keep it organised and so that we can import other view files in the future.
- Next we add the path to the urlpattern list:

urlpatterns = [
    path('admin/', admin.site.urls),
    path('register/', regView.register, name="register"),
    path('', include("main.urls")),
]

-now that we have linked the url to the view we need to create a template page. so in the register folder, create another folder called templates then in that folder create a file called register.html.
- Same chat as last time for the template but this time we need to specify a relative path to the base template since it is held in the main applications templates folder:
	
	{% extends "main/base.html" %}

-inside the block content we basically just make another form similar to how we made the create form earlier.
-Django automatically makes a form for registering/logging in/logging out which is can be used by importing the inbuilt modules, in the views file for the register app, import the modules and return the form to the page:
	
	from django.contrib.auth import login, authenticate
	from django.contrib.auth.forms import UserCreationForm

	def register(response):
    		form = UserCreationForm
    		return render(response, "register/register.html", {"form":form})
	
-right now the register page can be reached and the default Django register form can be seen, however , the functionality is not there at the moment so if you fill out the form and submit it, it will error because we have not told Django what to do withthe form at this time.
- we need to implement the functionality inside the view function the same way we did with the create form, through if statements:

def register(response):
    if response.method == "POST":
        form = UserCreationForm(response.POST)
        if form.is_valid():
            form.save()
    else:
        form = UserCreationForm

    return render(response, "register/register.html", {"form":form})

- this works well and the new users are created automatically in the users table of the database. 
-now we want to redirect users to another page once they sign up. start by importing redirect from the django short cuts library and then redirect them to the gome page after successful registration.
- since the default django form doesnt ask for email address or phone number, we wnat to change that. in the register application, create a new file called forms.py and import the following again:

from django import forms
from django.contrib.auth import login, authenticate
from django.contrib.auth.forms import UserCreationForm
from django.contrib.auth.models import User

- this gets a bit wierd so hold on tight:
-create a class called RegisterForm that inherits from the default django UserCreationForm that we just used. this gives us all the properties of the default form and gives us the nice layout as well.
-we create an email property using the django forms email field. here is where you can create any fields that you want on your custom form.
-within the class, we make another class which needs to be called Meta. This class will take the data from the RegisterForm and tell it where to be saved in the users database. for this to work we need the default django models (database tables) which we import above and specifically from the django models we want the User table.
-so in the Meta class we specify that the model is User and we provide the fields information in the order that we want it to be displayed in.
- Note that the username,password1 and password2 are alredy default fields of the form, we are only adding the email field but we then select the order we want them to be displayed in.


class RegisterForm(UserCreationForm):
    email = forms.EmailField()

    class Meta:
        model = User
        fields = ["username", "email", "password1", "password2"]

-Now that we have acutally created our own form, we can go back to the register view and change the references to the django default form to the nice one we just created/
-first remove the unnecessary defauolt django form imports and then imoport the class we just made

	from .forms import RegisterForms
-Now replace references to the old form in the if statements with the new form.


Styling the registration form
*****************************
- we are going to use a popular framework for Django forms called Crispy forms so install it into the virtual env with:
	
	pipenv install django-crispy-forms

-Before we can start using crispy forms, we need to go in to the project settings. In the installed apps list add 'crispy_forms', then at the very bottom of the page, add the line:
	
	CRISPY_TEMPLATE_PACK = "bootstrap4"
-this tells the framework to use the bootstrap 5 templates, as it uses version 2 by default.
-Next we go to the register template, just above the {%block content%} line we need to add the tag to bring the crispy forms into the mix:

	{% load crispy_forms_tags %}

- then we need to change the tag that brings through the form to include the crispy filter:

	 {{ form|crispy }}



Login Logout Pages
******************
-Thankfully Django does most of the heavy lifting on this one. the django.contrib.auth library is the boy which sorts us out form all the authentication shit.
-Start out in the project URLS page. in here we need to add a path to the contrib.auth application urls file which we can then in turn redirect to the default log in/out pages. so add the line below to the URL pattern list:
	
	    path('', include('django.contrib.auth.urls')),

-Next we need to create a new folder in the register application templates file which will hold the log in/out pages so create a folder inside the templates folder called registration.
- we then create a new html file called login.html this is where django will look to render our login page.
-create the html file just like the others with a form and stuff:

{% extends "main/base.html" %}
{% block title %}
Login Page
{% endblock %}

{% load crispy_forms_tags %}

{% block content %}
    <form method="post" class="form-group">
        {% csrf_token %}
        {{form|crispy}}
        <br>
        <button type="submit" name="login" class="btn btn-success">Login</button>
        <p>or click <a href="/register">here</a> to create an account</p>
    </form>
{% endblock %}

-now when we navigate to /login we can see the nice login page. This page is not quite functional yet as we need to add a redirect which takes place on successful logins. Unsuccessful logins are dealt with through JavaScript banners.
-to specify the login redirect, we need to go to the main settings file again, then at the very bottom andd the line below:

	LOGIN_REDIRECT_URL="/"
- this will now redirect successful logins to the home page.


User Authentication
*******************
- Whenever you go to a page in Django, it has a user attirbute that holds the current user. if you are not signed in, the user variable is classed as anonymous.
- we can use this user variable to check if a user has signed in or not and prevent them from accessing parts of the site accordingly.
-to do this, go to the base template and just before we have the block content, add the jinja if statement to check if  the user is authenticated:
	
	{% if user.is_authenticated %}

-I actually had to create an new base template in the registration app and remove the authentication block otherwise you cnnot get to the login page to log in lol if you were doing this professionally. you can access the user variable from the vview functions so you caould add a block of code in each view that checks if a user is authenticated per view, this way you can use the same base template for all pages.
- to change the logout page layout, go to the project settings file again and unfer the the login redirect line that we just wrote, add the same thing but change it to logout:

	LOGOUT_REDIRECT_URL = "/"

-Now that we can tell who is logged in, we can make it so that a user can see only their to do list and no one elses.
- to make this happen, we need to go to the main app's models file and add a foreign key to the todolist model which links to the django.contrib.auth user table(model).
-so first import the contrib User model:

	from django.contrib.auth.models import User

-then under the ToDoList model add the foreign key field:

	user = models.ForeignKey(User, on_delete=models.CASCADE)

- as we have been messing with the database models, we need to make migrations so that it is saved:
	
	python manage.py makemigrations
	python manage.py migrate
-now that we have added a foreign key to the to do table, we need to add a bit of code so that when we create a todo list, it checks which user is logged in then adds those details to the database entry.
- go to the main app's views.py file

Got messy towards the end.

Stuff to tidy up
*****************
-get rid of home page
-make it so you can only login or register efore signing in
-add a logout page
-remove second base template and make sure all authentication is handled before allowing the user into their lists









-































	








